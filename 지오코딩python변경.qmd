---
title: "Untitled"
format: html
---

# 데이터 수집
```{r}
library(XML)
library(httr)
library(data.table)
library(stringr)
library(tidyverse)
#법정동코드 41930

#요청기간
datelist <- seq(from = as.Date('2006-01-01'),
                to = as.Date('2025-12-31'),
                by= '1 days')
datelist <- format(datelist, format='%Y%m')

length(datelist)

#api요청해서 데이터 수집
service_key <- 'yQ3x5TpauR4TZTv3VVe7/GtT5ooGmknYKee5L9a5oOM0/oOHiKURlQ0FamByEQFWGM0NYNg204bG9mXY17T6HQ=='

url_list <- list()
cnt <- 0

for(i in 1:length(datelist)){
  cnt <- cnt +1
  
  url_list[cnt] <- paste0("https://apis.data.go.kr/1613000/RTMSDataSvcAptTrade/getRTMSDataSvcAptTrade?",
                          "LAWD_CD=",41390,
                          "&DEAL_YMD=",datelist[i],
                          "&numOfRows=",10000,
                          "&serviceKey=",service_key)
}

browseURL(paste0(url_list[48]))

raw_data <- list()
root_Node <- list()
total <- list()
dir.create('call_api')


for(i in 1:length(url_list)){
  xml_data <- GET(url_list[[i]], add_headers(Accept='application/xml','User-Agent'='Mozilla/5.0'))
  raw_data[[i]] <- xmlTreeParse(xml_data, useInternalNodes = TRUE, encoding='UTF-8')
  root_Node[[i]] <- xmlRoot(raw_data[[i]])
  
  items <- root_Node[[i]][[2]][['items']]
  size <- xmlSize(items)
  
  item <- list()
  item_temp_dt <- data.table()
  Sys.sleep(.1)
  
  apt_bind <- for(m in 1:size){
    item_temp <- xmlSApply(items[[m]],xmlValue)
    item_temp_dt <- data.table(
      year=item_temp[10],#거래년도
      month = item_temp[9], #거래 월
      day = item_temp[8], #거래 일
      price = item_temp[7], #거래금액
      code = item_temp[18], #지역 코드
      dong_nm = item_temp[20], #법정동
      jibun = item_temp[15], #지번
      con_year = item_temp[3], #건축 연도
      apt_nm = item_temp[2], #아파트 이름
      area = item_temp[13], #전용면적
      floor = item_temp[14]) #층수
    item[[m]] <- item_temp_dt}
  apt_bind <- rbindlist(list(apt_bind, rbindlist(item)), fill = TRUE)
}
write.csv(apt_bind, './apt_price2.csv')
apt_bind

```




# 데이터 전처리
```{r}
library(tidyverse)
price <- read_csv('apr_price.csv') |> select(-1,-code)

#결측값 확인
colSums(is.na(price)) #결측값 없다.

#시계열 분석을 위한 날짜 만들기
price <- price |> mutate(ymd= make_date(year,month,day))

price$ym <- floor_date(price$ymd, "month")

str(price)

price <- price |> mutate(juso_jibun = 
                           paste0(dong_nm, jibun, apt_nm))

price <- price |> mutate(py =
                           round(price/area *3.3,0))

price$cnt <- 1

write.csv(price, './price_last.csv', row.names = F)
read_csv('price_last.csv')
```


# 카카오 api로 지오코딩
```{r}
library(tidyverse)
price <- read_csv('price_last.csv')
price |> filter(dong_nm == '신천동' & apt_nm =='동진1')
head(price$juso_jibun,2)

apt_juso <- select(price, juso_jibun) |> distinct()
head(apt_juso)

add_list <- list()
cnt <- 0
kakao_key <- ''

library(httr)
library(data.table)
library(rjson)



for(i in 1:nrow(apt_juso)){
  #예외 처리구문 
  tryCatch({ #오류가 발생하여도 반복문을 멈추지 않고 진행하는 함수
    lon_lat <- GET(url='https://dapi.kakao.com/v2/local/search/address.json', #이거는 카카오 디벨롭 공식문서 참조
                   query = list(query=apt_juso[i,]),
                   add_headers(Authorization = paste0("KakaoAK ",kakao_key)))
    #위경도만 추출하여 저장
    coordxy <- lon_lat %>% content(as='text') %>% fromJSON()
    cnt <- cnt + 1
    add_list[[cnt]] <- data.table(apt_juso = apt_juso[i,],
                                  coord_x = coordxy$documents[[1]]$address$x,
                                  coord_y = coordxy$documents[[1]]$address$y)
    message <- paste0("[",i,"/",nrow(apt_juso),"]번째(",
                      round(i/nrow(apt_juso)*100, 2)," %) [",apt_juso[i,],"] 지오 코딩 중:
                      X=", add_list[[cnt]]$coord_x, "/ Y=",add_list[[cnt]]$coord_y)
    cat(message, "\n\n")
  }, error = function(e){cat("ERROR: ",conditionMessage(e),"\n")}
  )
}

juso_geocoding <- rbindlist(add_list)
juso_geocoding <- juso_geocoding |> mutate(across(c(coord_x, coord_y),as.numeric))
str(juso_geocoding)
colSums(is.na(juso_geocoding))
save(juso_geocoding,file='juso_geocoding.rdata')
write.csv(juso_geocoding, file='juso_geocoding.csv', row.names = F)
read_csv("juso_geocoding.csv")

```



# 지오 데이터프레임 만들기
```{r}
library(sp)
library(sf)
library(tidyverse)
price <- read_csv('price_last.csv')
load('juso_geocoding.rdata')
geocoding <- juso_geocoding |> rename(juso_jibun = apt_juso.juso_jibun)
apt_price <- left_join(price,geocoding)

str(apt_price)

colSums(is.na(apt_price))

apt_price <- na.omit(apt_price)


#좌푯값 할당
library(sp)

coordinates(apt_price) <- ~coord_x + coord_y #좌표값 할당

proj4string(apt_price) <- "+proj=longlat +datum=WGS84 +no_defs" #좌표계(CRS) 정의
#+proj=longlat: 이 데이터는 경도(longitude)와 위도(latitude) 좌표계에 기반을 둡니다.

#+datum=WGS84: 이 데이터는 WGS84 기준 좌표계 (World Geodetic System 1984)를 사용합니다.

#+no_defs: 기본 설정을 사용하지 않습니다.

library(sf)
geo_apt_price <- st_as_sf(apt_price)
str(geo_apt_price)
save(geo_apt_price,file='geo_apt_price.rdata')
write.csv(geo_apt_price,file='geo_apt_price.csv', row.names = F)



```


# 시흥시 grid 나누기

```{r}
library(sf)
library(raster)
library(sp)
shp1 <- st_read('./시흥시행정동/(B031)국가기본공간정보(경기도 시흥시)_NF_A_G01106/NF_A_G01106.shp')

# 셰이프 파일을 EPSG:5186 좌표계로 변환
shp1 <- st_transform(shp1, crs = 5186)

# 0.5km x 0.5km 그리드 생성
grid <- st_make_grid(
  shp1, 
  cellsize = c(500,500),  # 0.5km x 0.5km
  square = TRUE
)

# 생성된 그리드의 좌표계 확인
st_crs(grid)
# 시흥시 경계와 교차하는 그리드 필터링
grid_filtered <- st_intersection(grid, shp1)
ggplot() +
  geom_sf(data=grid_filtered)
# 결과 시각화
plot(st_geometry(shp1), col = "lightblue", main = "0.5km Grid Over 시흥시")
plot(st_geometry(grid_filtered), add = TRUE, border = "red")

save(grid_filtered, file='grid_siheung.rdata')

```

# 시각화

```{r}
library(sf)
library(tidyverse)
load('grid_siheung.rdata')
load('geo_apt_price.rdata')
shp1 <- st_read('./시흥시행정동/(B031)국가기본공간정보(경기도 시흥시)_NF_A_G01106/NF_A_G01106.shp')
unique(geo_apt_price$dong_nm)
unique(shp1$NAME)


#price <- st_join(geo_apt_price, shp1, join= st_intersects)
#이게 좌표계가 달라서 조인이 안됌

st_crs(shp1)
st_crs(geo_apt_price)
st_crs(grid_filtered)

#좌표계변경
#shp1 <- st_transform(shp1, st_crs(geo_apt_price))
grid <- st_transform(grid_filtered, st_crs(geo_apt_price)) |> st_sf()
st_crs(grid)

#price <- st_join(geo_apt_price, shp1, join= st_intersects) |> select(-c(17,18,19,20,21,22,23))


ggplot() +
  geom_sf(data = geo_apt_price, color = "blue", size = 0.5, alpha = 0.7) +
  geom_sf(data = shp1, fill = "transparent", color = "red") +
  labs(title = "Geo Apt Price vs 행정동 경계")
geo_apt_price |> filter(st_coordinates(geometry)[,1]>127.0 &
                          st_coordinates(geometry)[,2]<37) -> who2
price2 <- geo_apt_price |> filter(st_coordinates(geometry)[,1] < 127.0 &
                                            st_coordinates(geometry)[,2] > 37.0 & st_coordinates(geometry)[,2] < 37.5)


price2 |> filter(st_coordinates(geometry)[,1]>126.8 &
                  st_coordinates(geometry)[,2] < 37.33) ->who
who$geometry
ggplot() +
  geom_sf(data= who) +
  geom_sf(data=shp1)

price2_last <- price2 |> filter(st_coordinates(geometry)[,1] < 126.8963)

select(price2_last, dong_nm,juso_jibun) |> slice_head(n=30)

ggplot() +
  geom_sf(data = price2_last, color = "blue", size = 0.5, alpha = 0.7) +
  geom_sf(data= grid, fill='transparent',color='red')+
  coord_sf(xlim = c(126.6, 126.9), ylim = c(37.2, 37.48)) +
  labs(title = "Geo Apt Price vs 행정동 경계")


#grid_apt_price <- st_join(price2_last, st_sf(grid), join = st_intersects)

#save(grid_apt_price, file='grid_apt_price.rdata')
save(grid, file='grid.rdata')
save(price2_last, file='price2_last.rdata')
#--------------------------------------------------------#
load("price2_last.rdata")
load('grid.rdata')

price <- price2_last |> group_by(juso_jibun) |> mutate(avg_price = mean(py)) |> ungroup()
grid_price <- st_join(grid, price, join=st_intersects) 
colSums(is.na(grid_price))
grid_price <- na.omit(grid_price)

grid_price |> 
  ggplot() +
  geom_sf(aes(fill=avg_price)) +
  scale_fill_gradient(low='white',high='red',space="Lab")+
  theme_minimal() +
  labs(title = "시흥시 아파트 평균 가격 (0.5km Grid)") +
  theme(legend.position = "right")


#save(grid_price,file='grid_price.rdata')

##지도경계그리기
library(sp)
price_sp <- as(st_geometry(price), "Spatial") #sf=>sp변환
x <- coordinates(price_sp)[,1]
y <- coordinates(price_sp)[,2]


l1 <- bbox(price_sp)[1,1] - (bbox(price_sp)[1,1] * 0.001)
l2 <- bbox(price_sp)[1,2] + (bbox(price_sp)[1,2] * 0.001)
l3 <- bbox(price_sp)[2,1] - (bbox(price_sp)[2,1] * 0.001)
l4 <- bbox(price_sp)[2,2] + (bbox(price_sp)[2,2] * 0.001)

library(spatstat)
win <- owin(xrange=c(l1,l2),yrange=c(l3,l4))
plot(win)

#밀도 그래프 표시하기
p <- ppp(x, y, window = win)
d <- density.ppp(p, weight=price$avg_price,
                 sigma=bw.diggle(p),
                 kernel = 'gaussian')
plot(d)
d <- density.ppp(p, weights=price$avg_price, # 가중치 추가 
                 sigma=bw.diggle(p), kernel='gaussian')

#커널밀도함수에서 의미있는 데이터는 상위 25%정도
#이를 제거
d[d < quantile(d)[4] + (quantile(d)[4] *0.1)] <- NA #노이즈제거
library(raster)
raster_high <- raster(d)
plot(raster_high)

##시흥시 외곽경계생성
shp1 <- st_read('./시흥시행정동/(B031)국가기본공간정보(경기도 시흥시)_NF_A_G01106/NF_A_G01106.shp')
# 시흥시 전체 경계 결합
siheung_boundary <- st_union(shp1)

ggplot(data = siheung_boundary) +
  geom_sf(fill = "lightblue", color = "black") +
  labs(title = "Siheung City Boundary") +
  theme_minimal()

siheung_boundary_utm <- st_transform(siheung_boundary, crs = "+proj=longlat +datum=WGS84 +no_defs") |> as("Spatial")
st_crs(siheung_boundary_utm)

raster_high <- crop(raster_high, extent(siheung_boundary_utm))#외곽선 자르기
crs(raster_high) <- sp::CRS("+proj=longlat +datum=WGS84 +no_defs") #좌표계정의
plot(raster_high)
plot(siheung_boundary_utm, col=NA, border="red",add=T)

library(terra)
library(leaflet)


leaflet() |> 
  #--#기본지도불러오기
  addProviderTiles(providers$CartoDB.Positron) |> 
  #--# 서울시 경계선 불러오기
  addPolygons(data=siheung_boundary_utm, weight=3, color='red',fill=NA) |> 
  #--# 래스터이미지불러오기
  addRasterImage(raster_high,
                 colors=colorNumeric(c('blue','green','yellow','red'),
                                     values(raster_high),na.color = "transparent"),
                 opacity = 0.4)

save(raster_high, file='raster_high.rdata')
st_crs(raster_high)
st_crs(siheung_boundary_utm)
raster_high[is.na(raster_high)] <- 0
print(res(raster_high))  # 해상도 확인
print(extent(raster_high))  # 범위 확인

```


# 많이 오른 레스터

```{r}
library(tidyverse)
library(sf)
load("grid_price.rdata")
load('grid.rdata')

########7-2###########
#일정기간동안 가장 많이 가격이 오른 지역은 어디일까
kde_before <- st_drop_geometry(grid_price) |> filter(ymd<="2020-12-31") |> 
  group_by(juso_jibun) |> summarise(before = mean(py))
kde_after <- st_drop_geometry(grid_price) |> filter(ymd>='2021-01-01') |> 
  group_by(juso_jibun) |> summarise(after=mean(py))


kde_diff <- merge(kde_before,kde_after)
kde_diff$diff <- round(((kde_diff$after - kde_diff$before)/
                          (kde_diff$before)*100),0)


kde_diff <- kde_diff[kde_diff$diff>0,] #상승지역만 추출
kde_hot <- merge(grid_price,kde_diff,by="juso_jibun") |>distinct(juso_jibun, diff,before, after, st_transform.grid_filtered..st_crs.geo_apt_price..)
class(kde_hot)
#save(kde_hot, file='kde_hot_merge.rdata')
#load('kde_hot_merge.rdata')

head(kde_hot,2)
kde_hot |> ggplot(aes(fill=diff)) + 
  geom_sf() +
  scale_fill_gradient(low='white',high='red')


library(sp) 
kde_hot_sp <- as(st_geometry(kde_hot), "Spatial") # sf형 => sp형 변환
x <- coordinates(kde_hot_sp)[,1]  # 그리드 x, y 좌표 추출
y <- coordinates(kde_hot_sp)[,2] 

l1 <- bbox(kde_hot_sp)[1,1] - (bbox(kde_hot_sp)[1,1]*0.001) # 그리드 기준 경계지점 설정
l2 <- bbox(kde_hot_sp)[1,2] + (bbox(kde_hot_sp)[1,2]*0.001)
l3 <- bbox(kde_hot_sp)[2,1] - (bbox(kde_hot_sp)[2,1]*0.001)
l4 <- bbox(kde_hot_sp)[2,2] + (bbox(kde_hot_sp)[1,1]*0.001)

library(spatstat)  # install.packages("spatstat")
win <- owin(xrange=c(l1,l2), yrange=c(l3,l4))  # 경계지점 기준 외곽선 만들기(bounding-box)
plot(win)                                      # 확인

# [5단계: 밀도 그래프 변환하기]

p <- ppp(x, y, window=win, marks=kde_hot$diff) # 경계창 위에 좌표값 포인트 생성
d <- density.ppp(p, weights=kde_hot$diff,      # 포인트를 커널밀도 함수로 변환
                 sigma = bw.diggle(p), 
                 kernel = 'gaussian')
plot(d)   # 확인
rm(list = c("x", "y", "win","p")) # 변수 정리

#---# [6단계: 픽셀 -> 레스터 변환]

d[d < quantile(d)[4] + (quantile(d)[4]*0.1)] <- NA  # 노이즈 제거
library(raster)         # install.packages("raster")
raster_hot <- raster(d) # 레스터 변환
plot(raster_hot) #  확인

#---# [7단계: 클리핑]
shp1 <- st_read('./시흥시행정동/(B031)국가기본공간정보(경기도 시흥시)_NF_A_G01106/NF_A_G01106.shp')
# 시흥시 전체 경계 결합
siheung_boundary <- st_union(shp1)

siheung_boundary_utm <- st_transform(siheung_boundary, crs = "+proj=longlat +datum=WGS84 +no_defs") |> as("Spatial")

raster_hot <- crop(raster_hot, extent(siheung_boundary_utm))            # 외곽선 클리핑
crs(raster_hot) <- sp::CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84  
                        +towgs84=0,0,0")  # 좌표계 정의
plot(raster_hot)   #  확인
plot(siheung_boundary_utm, col=NA, border = "red", add=TRUE)

library(leaflet)
leaflet() |> 
  addProviderTiles(providers$CartoDB.Positron) |> 
  addPolygons(data=siheung_boundary_utm,weight=3,color='red',fill=NA) |> 
  addRasterImage(raster_hot,
                 colors=colorNumeric(c('yellow','blue','green','red'),
                                     values(raster_hot),na.color='transparent'),
                 opacity=0.4)
save(raster_hot,file='kde_hot.rdata')
#rm(list=ls())




```